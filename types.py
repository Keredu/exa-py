# generated by datamodel-codegen:
#   filename:  public.yaml
#   timestamp: 2025-07-10T01:23:44+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import AnyUrl, BaseModel, Field, PositiveFloat, confloat, conint, constr


class CompanyEntity(BaseModel):
    type: str = Field('company', const=True)


class PersonEntity(BaseModel):
    type: str = Field('person', const=True)


class ArticleEntity(BaseModel):
    type: str = Field('article', const=True)


class ResearchPaperEntity(BaseModel):
    type: str = Field('research_paper', const=True)


class CustomEntity(BaseModel):
    type: str = Field('custom', const=True)
    description: constr(min_length=2, max_length=200)


class Entity(BaseModel):
    __root__: Union[
        CompanyEntity, PersonEntity, ArticleEntity, ResearchPaperEntity, CustomEntity
    ]


class CreateCriterionParameters(BaseModel):
    description: constr(min_length=1, max_length=1000) = Field(
        ..., description='The description of the criterion'
    )


class Format(Enum):
    text = 'text'
    date = 'date'
    number = 'number'
    options = 'options'
    email = 'email'
    phone = 'phone'


class Option(BaseModel):
    label: str = Field(..., description='The label of the option')


class CreateEnrichmentParameters(BaseModel):
    description: constr(min_length=1, max_length=5000) = Field(
        ...,
        description='Provide a description of the enrichment task you want to perform to each Webset Item.',
    )
    format: Optional[Format] = Field(
        None,
        description='Format of the enrichment response.\n\nWe automatically select the best format based on the description. If you want to explicitly specify the format, you can do so here.',
    )
    options: Optional[List[Option]] = Field(
        None,
        description='When the format is options, the different options for the enrichment agent to choose from.',
        max_items=150,
        min_items=1,
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )


class Source(Enum):
    import_ = 'import'
    webset = 'webset'


class ExcludeItem(BaseModel):
    source: Source
    id: constr(min_length=1) = Field(
        ..., description='The ID of the source to exclude.'
    )


class Search(BaseModel):
    query: constr(min_length=1, max_length=5000) = Field(
        ...,
        description='Natural language search query describing what you are looking for.\n\nBe specific and descriptive about your requirements, characteristics, and any constraints that help narrow down the results.\n\nAny URLs provided will be crawled and used as additional context for the search.',
        examples=[
            'Marketing agencies based in the US, that focus on consumer products.',
            'AI startups in Europe that raised Series A funding in 2024',
            'SaaS companies with 50-200 employees in the fintech space',
        ],
    )
    count: Optional[confloat(ge=1.0)] = Field(
        10,
        description='Number of Items the Webset will attempt to find.\n\nThe actual number of Items found may be less than this number depending on the search complexity.',
    )
    entity: Optional[Entity] = Field(
        None,
        description='Entity the Webset will return results for.\n\nIt is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control.',
    )
    criteria: Optional[List[CreateCriterionParameters]] = Field(
        None,
        description="Criteria every item is evaluated against.\n\nIt's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. Only use this when you need more fine control.",
        max_items=5,
        min_items=1,
    )
    recall: Optional[bool] = Field(
        None,
        description='Whether to provide an estimate of how many total relevant results could exist for this search.\nResult of the analysis will be available in the `recall` field within the search request.',
    )
    exclude: Optional[List[ExcludeItem]] = Field(
        None,
        description='Sources (existing imports or websets) to exclude from search results. Any results found within these sources will be omitted to prevent finding them during search.',
    )


class ImportItem(BaseModel):
    source: Source
    id: constr(min_length=1) = Field(..., description='The ID of the source to search.')


class CreateWebsetParameters(BaseModel):
    search: Optional[Search] = Field(
        None, description='Create initial search for the Webset.'
    )
    import_: Optional[List[ImportItem]] = Field(
        None,
        alias='import',
        description='Import data from existing Websets and Imports into this Webset.',
    )
    enrichments: Optional[List[CreateEnrichmentParameters]] = Field(
        None,
        description='Add enrichments to extract additional data from found items.\n\nEnrichments automatically search for and extract specific information (like contact details, funding data, employee counts, etc.) from each item added to your Webset.',
    )
    externalId: Optional[constr(max_length=300)] = Field(
        None,
        description='The external identifier for the webset.\n\nYou can use this to reference the Webset by your own internal identifiers.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )


class Status(Enum):
    created = 'created'
    running = 'running'
    completed = 'completed'
    canceled = 'canceled'


class Criterion(BaseModel):
    description: constr(min_length=1, max_length=1000) = Field(
        ..., description='The description of the criterion'
    )
    successRate: confloat(ge=0.0, le=100.0) = Field(
        ...,
        description='Value between 0 and 100 representing the percentage of results that meet the criterion.',
    )


class ExcludeItem1(BaseModel):
    source: Source
    id: str


class Progress(BaseModel):
    found: float = Field(..., description='The number of results found so far')
    analyzed: float = Field(..., description='The number of results analyzed so far')
    completion: confloat(ge=0.0, le=100.0) = Field(
        ..., description='The completion percentage of the search'
    )
    timeLeft: float = Field(
        ..., description='The estimated time remaining in seconds, null if unknown'
    )


class Confidence(Enum):
    high = 'high'
    medium = 'medium'
    low = 'low'


class Bounds(BaseModel):
    min: float = Field(
        ..., description='The minimum estimated total number of potential matches'
    )
    max: float = Field(
        ..., description='The maximum estimated total number of potential matches'
    )


class Expected(BaseModel):
    total: float = Field(
        ..., description='The estimated total number of potential matches'
    )
    confidence: Confidence = Field(..., description='The confidence in the estimate')
    bounds: Bounds


class Recall(BaseModel):
    expected: Expected
    reasoning: str = Field(..., description='The reasoning for the estimate')


class Object(Enum):
    import_ = 'import'


class Status1(Enum):
    pending = 'pending'
    processing = 'processing'
    completed = 'completed'
    failed = 'failed'


class Format1(Enum):
    csv = 'csv'
    webset = 'webset'


class FailedReason(Enum):
    invalid_format = 'invalid_format'
    invalid_file_content = 'invalid_file_content'
    missing_identifier = 'missing_identifier'


class Import(BaseModel):
    id: str = Field(..., description='The unique identifier for the Import')
    object: Object = Field(..., description='The type of object')
    status: Status1 = Field(..., description='The status of the Import')
    format: Format1 = Field(..., description='The format of the import.')
    entity: Entity = Field(..., description='The type of entity the import contains.')
    title: str = Field(..., description='The title of the import')
    count: float = Field(..., description='The number of entities in the import')
    metadata: Dict[str, Any] = Field(
        ...,
        description='Set of key-value pairs you want to associate with this object.',
    )
    failedReason: FailedReason = Field(..., description='The reason the import failed')
    failedAt: datetime = Field(..., description='When the import failed')
    failedMessage: str = Field(
        ..., description='A human readable message of the import failure'
    )
    createdAt: datetime = Field(..., description='When the import was created')
    updatedAt: datetime = Field(..., description='When the import was last updated')


class Status2(Enum):
    pending = 'pending'
    canceled = 'canceled'
    completed = 'completed'


class Object1(Enum):
    monitor_run = 'monitor_run'


class Status3(Enum):
    created = 'created'
    running = 'running'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'


class Type(Enum):
    search = 'search'
    refresh = 'refresh'


class MonitorRun(BaseModel):
    id: str = Field(..., description='The unique identifier for the Monitor Run')
    object: Object1 = Field(..., description='The type of object')
    status: Status3 = Field(..., description='The status of the Monitor Run')
    monitorId: str = Field(
        ..., description='The monitor that the run is associated with'
    )
    type: Type = Field(..., description='The type of the Monitor Run')
    completedAt: datetime = Field(..., description='When the run completed')
    failedAt: datetime = Field(..., description='When the run failed')
    failedReason: str = Field(..., description='The reason the run failed')
    canceledAt: datetime = Field(..., description='When the run was canceled')
    createdAt: datetime = Field(..., description='When the run was created')
    updatedAt: datetime = Field(..., description='When the run was last updated')


class Object2(Enum):
    monitor = 'monitor'


class Status4(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class Cadence(BaseModel):
    cron: str = Field(
        ...,
        description='Cron expression for monitor cadence (must be a valid Unix cron with 5 fields). The schedule must trigger at most once per day.',
    )
    timezone: Optional[str] = Field(
        'Etc/UTC', description='IANA timezone (e.g., "America/New_York")'
    )


class Criterion1(BaseModel):
    description: constr(min_length=2, max_length=1000)


class Behavior1(Enum):
    override = 'override'
    append = 'append'


class Config(BaseModel):
    query: Optional[constr(min_length=2, max_length=10000)] = Field(
        None,
        description='The query to search for. By default, the query from the last search is used.',
    )
    criteria: Optional[List[Criterion1]] = Field(
        None,
        description='The criteria to search for. By default, the criteria from the last search is used.',
        max_items=5,
    )
    entity: Optional[Entity] = Field(
        None,
        description='The entity to search for. By default, the entity from the last search/import is used.',
        title='Entity',
    )
    count: PositiveFloat = Field(
        ..., description='The maximum number of results to find'
    )
    behavior: Optional[Behavior1] = Field(
        'append',
        description='The behaviour of the Search when it is added to a Webset.',
    )


class Behavior(BaseModel):
    type: str = Field('search', const=True)
    config: Config = Field(
        ...,
        description='Specify the search parameters for the Monitor.\n\nBy default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided.',
    )


class Monitor(BaseModel):
    id: str = Field(..., description='The unique identifier for the Monitor')
    object: Object2 = Field(..., description='The type of object')
    status: Status4 = Field(..., description='The status of the Monitor')
    websetId: str = Field(
        ..., description='The id of the Webset the Monitor belongs to'
    )
    cadence: Cadence = Field(..., description='How often the monitor will run')
    behavior: Behavior = Field(..., description='Behavior to perform when monitor runs')
    lastRun: MonitorRun = Field(
        ..., description='The last run of the monitor', title='MonitorRun'
    )
    nextRunAt: datetime = Field(
        ..., description='Date and time when the next run will occur in'
    )
    metadata: Dict[str, Any] = Field(
        ...,
        description='Set of key-value pairs you want to associate with this object.',
    )
    createdAt: datetime = Field(..., description='When the monitor was created')
    updatedAt: datetime = Field(..., description='When the monitor was last updated')


class Status5(Enum):
    idle = 'idle'
    running = 'running'
    paused = 'paused'


class Company(BaseModel):
    name: str = Field(..., description='The name of the company')
    location: str = Field(
        ..., description='The location the person is working at the company'
    )


class Person(BaseModel):
    name: str = Field(..., description='The name of the person')
    location: str = Field(..., description='The location of the person')
    position: str = Field(..., description='The current work position of the person')
    company: Company = Field(..., title='WebsetItemPersonCompanyPropertiesFields')
    pictureUrl: AnyUrl = Field(..., description='The image URL of the person')


class WebsetItemPersonProperties(BaseModel):
    type: str = Field('person', const=True)
    url: AnyUrl = Field(..., description='The URL of the person profile')
    description: str = Field(
        ..., description='Short description of the relevance of the person'
    )
    person: Person = Field(..., title='WebsetItemPersonPropertiesFields')


class Company1(BaseModel):
    name: str = Field(..., description='The name of the company')
    location: str = Field(..., description='The main location of the company')
    employees: float = Field(..., description='The number of employees of the company')
    industry: str = Field(..., description='The industry of the company')
    about: str = Field(..., description='A short description of the company')
    logoUrl: AnyUrl = Field(..., description='The logo URL of the company')


class WebsetItemCompanyProperties(BaseModel):
    type: str = Field('company', const=True)
    url: AnyUrl = Field(..., description='The URL of the company website')
    description: str = Field(
        ..., description='Short description of the relevance of the company'
    )
    content: str = Field(..., description='The text content of the company website')
    company: Company1 = Field(..., title='WebsetItemCompanyPropertiesFields')


class Article(BaseModel):
    title: str = Field(..., description='The title of the article')
    author: str = Field(..., description='The author(s) of the article')
    publishedAt: str = Field(
        ..., description='The date and time the article was published'
    )


class WebsetItemArticleProperties(BaseModel):
    type: str = Field('article', const=True)
    url: AnyUrl = Field(..., description='The URL of the article')
    description: str = Field(
        ..., description='Short description of the relevance of the article'
    )
    content: str = Field(..., description='The text content for the article')
    article: Article = Field(..., title='WebsetItemArticlePropertiesFields')


class ResearchPaper(BaseModel):
    title: str = Field(..., description='The title of the research paper')
    author: str = Field(..., description='The author(s) of the research paper')
    publishedAt: str = Field(
        ..., description='The date and time the research paper was published'
    )


class WebsetItemResearchPaperProperties(BaseModel):
    type: str = Field('research_paper', const=True)
    url: AnyUrl = Field(..., description='The URL of the research paper')
    description: str = Field(
        ..., description='Short description of the relevance of the research paper'
    )
    content: str = Field(..., description='The text content of the research paper')
    researchPaper: ResearchPaper = Field(
        ..., title='WebsetItemResearchPaperPropertiesFields'
    )


class Custom(BaseModel):
    title: str = Field(..., description='The title of the website')
    author: str = Field(..., description='The author(s) of the website')
    publishedAt: str = Field(
        ..., description='The date and time the website was published'
    )


class WebsetItemCustomProperties(BaseModel):
    type: str = Field('custom', const=True)
    url: AnyUrl = Field(..., description='The URL of the Item')
    description: str = Field(..., description='Short description of the Item')
    content: str = Field(..., description='The text content of the Item')
    custom: Custom = Field(..., title='WebsetItemCustomPropertiesFields')


class Satisfied(Enum):
    yes = 'yes'
    no = 'no'
    unclear = 'unclear'


class Reference(BaseModel):
    title: str = Field(..., description='The title of the reference')
    snippet: str = Field(
        ..., description='The relevant snippet of the reference content'
    )
    url: AnyUrl = Field(..., description='The URL of the reference')


class WebsetItemEvaluation(BaseModel):
    criterion: str = Field(..., description='The description of the criterion')
    reasoning: str = Field(
        ..., description='The reasoning for the result of the evaluation'
    )
    satisfied: Satisfied = Field(..., description='The satisfaction of the criterion')
    references: Optional[List[Reference]] = Field(
        [], description='The references used to generate the result.'
    )
    source: Optional[str] = Field(None, description='The source of the criterion')
    sourceType: Optional[str] = Field(
        None, description='The source type of the criterion'
    )


class Status6(Enum):
    pending = 'pending'
    completed = 'completed'
    canceled = 'canceled'


class Source3(Enum):
    search = 'search'
    import_ = 'import'


class UpdateWebsetRequest(BaseModel):
    metadata: Optional[Dict[str, constr(max_length=1000)]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )


class Status7(Enum):
    active = 'active'
    inactive = 'inactive'


class EventType(Enum):
    webset_created = 'webset.created'
    webset_deleted = 'webset.deleted'
    webset_paused = 'webset.paused'
    webset_idle = 'webset.idle'
    webset_search_created = 'webset.search.created'
    webset_search_canceled = 'webset.search.canceled'
    webset_search_completed = 'webset.search.completed'
    webset_search_updated = 'webset.search.updated'
    import_created = 'import.created'
    import_completed = 'import.completed'
    import_processing = 'import.processing'
    webset_item_created = 'webset.item.created'
    webset_item_enriched = 'webset.item.enriched'
    webset_export_created = 'webset.export.created'
    webset_export_completed = 'webset.export.completed'


class WebhookAttempt(BaseModel):
    id: str = Field(..., description='The unique identifier for the webhook attempt')
    object: str = Field('webhook_attempt', const=True)
    eventId: str = Field(..., description='The unique identifier for the event')
    eventType: EventType = Field(..., description='The type of event')
    webhookId: str = Field(..., description='The unique identifier for the webhook')
    url: str = Field(..., description='The URL that was used during the attempt')
    successful: bool = Field(..., description='Whether the attempt was successful')
    responseHeaders: Dict[str, Any] = Field(
        ..., description='The headers of the response'
    )
    responseBody: str = Field(..., description='The body of the response')
    responseStatusCode: float = Field(
        ..., description='The status code of the response'
    )
    attempt: float = Field(..., description='The attempt number of the webhook')
    attemptedAt: datetime = Field(
        ..., description='The date and time the webhook attempt was made'
    )


class ListWebhookAttemptsResponse(BaseModel):
    data: List[WebhookAttempt] = Field(..., description='The list of webhook attempts')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class Source4(Enum):
    import_ = 'import'
    webset = 'webset'


class ExcludeItem2(BaseModel):
    source: Source4
    id: constr(min_length=1) = Field(
        ..., description='The ID of the source to exclude.'
    )


class Behavior3(Enum):
    override = 'override'
    append = 'append'


class Config1(BaseModel):
    query: Optional[constr(min_length=2, max_length=10000)] = Field(
        None,
        description='The query to search for. By default, the query from the last search is used.',
    )
    criteria: Optional[List[Criterion1]] = Field(
        None,
        description='The criteria to search for. By default, the criteria from the last search is used.',
        max_items=5,
    )
    entity: Optional[Entity] = Field(
        None,
        description='The entity to search for. By default, the entity from the last search/import is used.',
        title='Entity',
    )
    count: PositiveFloat = Field(
        ..., description='The maximum number of results to find'
    )
    behavior: Optional[Behavior3] = Field(
        'append',
        description='The behaviour of the Search when it is added to a Webset.',
    )


class Behavior2(BaseModel):
    type: str = Field('search', const=True)
    config: Config1 = Field(
        ...,
        description='Specify the search parameters for the Monitor.\n\nBy default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided.',
    )


class CreateMonitorParameters(BaseModel):
    websetId: str = Field(..., description='The id of the Webset')
    cadence: Cadence = Field(..., description='How often the monitor will run')
    behavior: Behavior2 = Field(
        ..., description='Behavior to perform when monitor runs'
    )
    metadata: Optional[Dict[str, Any]] = None


class ListMonitorsResponse(BaseModel):
    data: List[Monitor] = Field(..., description='The list of monitors')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class MonitorCadence(BaseModel):
    cron: str = Field(
        ...,
        description='Cron expression for monitor cadence (must be a valid Unix cron with 5 fields). The schedule must trigger at most once per day.',
    )
    timezone: Optional[str] = Field(
        'Etc/UTC', description='IANA timezone (e.g., "America/New_York")'
    )


class Behavior4(Enum):
    override = 'override'
    append = 'append'


class Config2(BaseModel):
    query: Optional[constr(min_length=2, max_length=10000)] = Field(
        None,
        description='The query to search for. By default, the query from the last search is used.',
    )
    criteria: Optional[List[Criterion1]] = Field(
        None,
        description='The criteria to search for. By default, the criteria from the last search is used.',
        max_items=5,
    )
    entity: Optional[Entity] = Field(
        None,
        description='The entity to search for. By default, the entity from the last search/import is used.',
        title='Entity',
    )
    count: PositiveFloat = Field(
        ..., description='The maximum number of results to find'
    )
    behavior: Optional[Behavior4] = Field(
        'append',
        description='The behaviour of the Search when it is added to a Webset.',
    )


class MonitorBehavior(BaseModel):
    type: str = Field('search', const=True)
    config: Config2 = Field(
        ...,
        description='Specify the search parameters for the Monitor.\n\nBy default, the search parameters (query, entity and criteria) from the last search are used when no parameters are provided.',
    )


class Status8(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class UpdateMonitor(BaseModel):
    status: Optional[Status8] = Field(None, description='The status of the monitor.')
    metadata: Optional[Dict[str, Any]] = None
    cadence: Optional[MonitorCadence] = None
    behavior: Optional[MonitorBehavior] = None


class ListMonitorRunsResponse(BaseModel):
    data: List[MonitorRun] = Field(..., description='The list of monitor runs')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class Format2(Enum):
    csv = 'csv'


class Csv(BaseModel):
    identifier: Optional[conint(ge=0)] = Field(
        None,
        description='Column containing the key identifier for the entity (e.g. URL, Name, etc.). If not provided, we will try to infer it from the file.',
    )


class CreateImportParameters1(BaseModel):
    size: confloat(le=50000000.0) = Field(
        ..., description='The size of the file in megabytes. Maximum size is 50 MB.'
    )
    count: float = Field(..., description='The number of records to import')
    title: Optional[str] = Field(None, description='The title of the import')
    format: Format2 = Field(
        ...,
        description='When the import is in CSV format, we expect a column containing the key identifier for the entity - for now URL. If not provided, import will fail to be processed.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )
    entity: Union[
        CompanyEntity, PersonEntity, ArticleEntity, ResearchPaperEntity, CustomEntity
    ] = Field(
        ...,
        description='What type of entity the import contains (e.g. People, Companies, etc.), and thus should be attempted to be resolved as.',
    )
    csv: Optional[Csv] = Field(
        None,
        description='When format is `csv`, these are the specific import parameters.',
    )


class CreateImportParameters(BaseModel):
    __root__: CreateImportParameters1 = Field(..., discriminator='format')


class Object3(Enum):
    import_ = 'import'


class Status9(Enum):
    pending = 'pending'
    processing = 'processing'
    completed = 'completed'
    failed = 'failed'


class Format3(Enum):
    csv = 'csv'
    webset = 'webset'


class CreateImportResponse(BaseModel):
    id: str = Field(..., description='The unique identifier for the Import')
    object: Object3 = Field(..., description='The type of object')
    status: Status9 = Field(..., description='The status of the Import')
    format: Format3 = Field(..., description='The format of the import.')
    entity: Entity = Field(..., description='The type of entity the import contains.')
    title: str = Field(..., description='The title of the import')
    count: float = Field(..., description='The number of entities in the import')
    metadata: Dict[str, Any] = Field(
        ...,
        description='Set of key-value pairs you want to associate with this object.',
    )
    failedReason: FailedReason = Field(..., description='The reason the import failed')
    failedAt: datetime = Field(..., description='When the import failed')
    failedMessage: str = Field(
        ..., description='A human readable message of the import failure'
    )
    createdAt: datetime = Field(..., description='When the import was created')
    updatedAt: datetime = Field(..., description='When the import was last updated')
    uploadUrl: str = Field(..., description='The URL to upload the file to')
    uploadValidUntil: str = Field(
        ...,
        description='The date and time until the upload URL is valid. The upload URL will be valid for 1 hour.',
    )


class ListImportsResponse(BaseModel):
    data: List[Import] = Field(..., description='The list of imports')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class UpdateImport(BaseModel):
    metadata: Optional[Dict[str, Any]] = None
    title: Optional[str] = None


class WebsetEnrichmentFormat(Enum):
    text = 'text'
    date = 'date'
    number = 'number'
    options = 'options'
    email = 'email'
    phone = 'phone'


class WebsetSearchBehavior(Enum):
    override = 'override'
    append = 'append'


class WebsetSearchCanceledReason(Enum):
    webset_deleted = 'webset_deleted'
    webset_canceled = 'webset_canceled'


class WebsetSearch(BaseModel):
    id: str = Field(..., description='The unique identifier for the search')
    object: str = Field('webset_search', const=True)
    status: Status = Field(
        ..., description='The status of the search', title='WebsetSearchStatus'
    )
    query: constr(min_length=1, max_length=5000) = Field(
        ..., description='The query used to create the search.'
    )
    entity: Entity = Field(
        ...,
        description='The entity the search will return results for.\n\nWhen no entity is provided during creation, we will automatically select the best entity based on the query.',
    )
    criteria: List[Criterion] = Field(
        ...,
        description='The criteria the search will use to evaluate the results. If not provided, we will automatically generate them for you.',
    )
    count: confloat(ge=1.0) = Field(
        ...,
        description='The number of results the search will attempt to find. The actual number of results may be less than this number depending on the search complexity.',
    )
    behavior: Optional[WebsetSearchBehavior] = Field(
        'override',
        description="The behavior of the search when it is added to a Webset.\n\n- `override`: the search will replace the existing Items found in the Webset and evaluate them against the new criteria. Any Items that don't match the new criteria will be discarded.\n- `append`: the search will add the new Items found to the existing Webset. Any Items that don't match the new criteria will be discarded.",
    )
    exclude: List[ExcludeItem1] = Field(
        ...,
        description='Sources (existing imports or websets) used to omit certain results to be found during the search.',
    )
    progress: Progress = Field(..., description='The progress of the search')
    recall: Recall = Field(
        ...,
        description='Recall metrics for the search, null if not yet computed or requested.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        {}, description='Set of key-value pairs you want to associate with this object.'
    )
    canceledAt: datetime = Field(
        ..., description='The date and time the search was canceled'
    )
    canceledReason: WebsetSearchCanceledReason = Field(
        ..., description='The reason the search was canceled'
    )
    createdAt: datetime = Field(
        ..., description='The date and time the search was created'
    )
    updatedAt: datetime = Field(
        ..., description='The date and time the search was updated'
    )


class WebsetEnrichment(BaseModel):
    id: str = Field(..., description='The unique identifier for the enrichment')
    object: str = Field('webset_enrichment', const=True)
    status: Status2 = Field(
        ..., description='The status of the enrichment', title='WebsetEnrichmentStatus'
    )
    websetId: str = Field(
        ...,
        description='The unique identifier for the Webset this enrichment belongs to.',
    )
    title: str = Field(
        ...,
        description='The title of the enrichment.\n\nThis will be automatically generated based on the description and format.',
    )
    description: str = Field(
        ...,
        description='The description of the enrichment task provided during the creation of the enrichment.',
    )
    format: WebsetEnrichmentFormat = Field(
        ..., description='The format of the enrichment response.'
    )
    options: List[Option] = Field(
        ...,
        description='When the format is options, the different options for the enrichment agent to choose from.',
        title='WebsetEnrichmentOptions',
    )
    instructions: str = Field(
        ...,
        description='The instructions for the enrichment Agent.\n\nThis will be automatically generated based on the description and format.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        {}, description='The metadata of the enrichment'
    )
    createdAt: datetime = Field(
        ..., description='The date and time the enrichment was created'
    )
    updatedAt: datetime = Field(
        ..., description='The date and time the enrichment was updated'
    )


class Webset(BaseModel):
    id: str = Field(..., description='The unique identifier for the webset')
    object: str = Field('webset', const=True)
    status: Status5 = Field(
        ..., description='The status of the webset', title='WebsetStatus'
    )
    externalId: str = Field(..., description='The external identifier for the webset')
    title: str = Field(..., description='The title of the webset')
    searches: List[WebsetSearch] = Field(
        ..., description='The searches that have been performed on the webset.'
    )
    imports: List[Import] = Field(
        ..., description='Imports that have been performed on the webset.'
    )
    enrichments: List[WebsetEnrichment] = Field(
        ..., description='The Enrichments to apply to the Webset Items.'
    )
    monitors: List[Monitor] = Field(..., description='The Monitors for the Webset.')
    streams: List[Any] = Field(..., description='The Streams for the Webset.')
    metadata: Optional[Dict[str, Any]] = Field(
        {}, description='Set of key-value pairs you want to associate with this object.'
    )
    createdAt: datetime = Field(
        ..., description='The date and time the webset was created'
    )
    updatedAt: datetime = Field(
        ..., description='The date and time the webset was updated'
    )


class EnrichmentResult(BaseModel):
    object: str = Field('enrichment_result', const=True)
    status: Status6 = Field(..., description='The status of the enrichment result.')
    format: WebsetEnrichmentFormat
    result: List[str] = Field(..., description='The result of the enrichment.')
    reasoning: str = Field(
        ..., description='The reasoning for the result when an Agent is used.'
    )
    references: List[Reference] = Field(
        ..., description='The references used to generate the result.'
    )
    enrichmentId: str = Field(
        ..., description='The id of the Enrichment that generated the result'
    )


class WebsetItem(BaseModel):
    id: str = Field(..., description='The unique identifier for the Webset Item')
    object: str = Field('webset_item', const=True)
    source: Source3 = Field(..., description='The source of the Item')
    sourceId: str = Field(..., description='The unique identifier for the source')
    websetId: str = Field(
        ..., description='The unique identifier for the Webset this Item belongs to.'
    )
    properties: Union[
        WebsetItemPersonProperties,
        WebsetItemCompanyProperties,
        WebsetItemArticleProperties,
        WebsetItemResearchPaperProperties,
        WebsetItemCustomProperties,
    ] = Field(..., description='The properties of the Item')
    evaluations: List[WebsetItemEvaluation] = Field(
        ..., description='The criteria evaluations of the item'
    )
    enrichments: List[EnrichmentResult] = Field(
        ..., description='The enrichments results of the Webset item'
    )
    createdAt: datetime = Field(
        ..., description='The date and time the item was created'
    )
    updatedAt: datetime = Field(
        ..., description='The date and time the item was last updated'
    )


class GetWebsetResponse(Webset):
    items: Optional[List[WebsetItem]] = Field(
        None,
        description='When expand query parameter contains `items`, this will contain the items in the webset',
    )


class ListWebsetsResponse(BaseModel):
    data: List[Webset] = Field(..., description='The list of websets')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class ListWebsetItemResponse(BaseModel):
    data: List[WebsetItem] = Field(..., description='The list of webset items')
    hasMore: bool = Field(
        ..., description='Whether there are more Items to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of Items'
    )


class CreateWebhookParameters(BaseModel):
    events: List[EventType] = Field(
        ..., description='The events to trigger the webhook', max_items=15, min_items=1
    )
    url: AnyUrl = Field(..., description='The URL to send the webhook to')
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )


class Webhook(BaseModel):
    id: str = Field(..., description='The unique identifier for the webhook')
    object: str = Field('webhook', const=True)
    status: Status7 = Field(
        ..., description='The status of the webhook', title='WebhookStatus'
    )
    events: List[EventType] = Field(
        ..., description='The events to trigger the webhook', min_items=1
    )
    url: AnyUrl = Field(..., description='The URL to send the webhook to')
    secret: str = Field(
        ...,
        description='The secret to verify the webhook signature. Only returned on Webhook creation.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        {}, description='The metadata of the webhook'
    )
    createdAt: datetime = Field(
        ..., description='The date and time the webhook was created'
    )
    updatedAt: datetime = Field(
        ..., description='The date and time the webhook was last updated'
    )


class UpdateWebhookParameters(BaseModel):
    events: Optional[List[EventType]] = Field(
        None, description='The events to trigger the webhook', max_items=15, min_items=1
    )
    url: Optional[AnyUrl] = Field(None, description='The URL to send the webhook to')
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )


class ListWebhooksResponse(BaseModel):
    data: List[Webhook] = Field(..., description='The list of webhooks')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class Event1(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['0#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: Webset
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event2(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['1#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: Webset
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event3(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['2#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: Webset
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event4(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['3#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: Webset
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event5(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['4#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetItem
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event6(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['5#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetItem
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event7(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['6#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetSearch
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event8(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['7#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetSearch
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event9(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['8#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetSearch
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event10(BaseModel):
    id: str = Field(..., description='The unique identifier for the event')
    object: str = Field('event', const=True)
    type: Literal['9#-datamodel-code-generator-#-object-#-special-#'] = Field(
        ..., const=True
    )
    data: WebsetSearch
    createdAt: datetime = Field(
        ..., description='The date and time the event was created'
    )


class Event(BaseModel):
    __root__: Union[
        Event1, Event2, Event3, Event4, Event5, Event6, Event7, Event8, Event9, Event10
    ] = Field(..., discriminator='type', title='Event')


class ListEventsResponse(BaseModel):
    data: List[Event] = Field(..., description='The list of events')
    hasMore: bool = Field(
        ..., description='Whether there are more results to paginate through'
    )
    nextCursor: str = Field(
        ..., description='The cursor to paginate through the next set of results'
    )


class CreateWebsetSearchParameters(BaseModel):
    count: confloat(ge=1.0) = Field(
        ...,
        description='Number of Items the Search will attempt to find.\n\nThe actual number of Items found may be less than this number depending on the query complexity.',
    )
    query: constr(min_length=1, max_length=5000) = Field(
        ...,
        description='Natural language search query describing what you are looking for.\n\nBe specific and descriptive about your requirements, characteristics, and any constraints that help narrow down the results.\n\nAny URLs provided will be crawled and used as additional context for the search.',
        examples=[
            'Marketing agencies based in the US, that focus on consumer products. Get brands worked with and city',
            'AI startups in Europe that raised Series A funding in 2024',
            'SaaS companies with 50-200 employees in the fintech space',
        ],
    )
    entity: Optional[Entity] = Field(
        None,
        description='Entity the search will return results for.\n\nIt is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control.',
    )
    criteria: Optional[List[CreateCriterionParameters]] = Field(
        None,
        description="Criteria every item is evaluated against.\n\nIt's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. Only use this when you need more fine control.",
        max_items=5,
        min_items=1,
    )
    exclude: Optional[List[ExcludeItem2]] = Field(
        None,
        description='Sources (existing imports or websets) to exclude from search results. Any results found within these sources will be omitted to prevent finding them during search.',
    )
    recall: Optional[bool] = Field(
        None,
        description='Whether to provide an estimate of how many total relevant results could exist for this search.\nResult of the analysis will be available in the `recall` field within the search request.',
    )
    behavior: Optional[WebsetSearchBehavior] = Field(
        'override',
        description='How this search interacts with existing items in the Webset:\n\n- **override**: Replace existing items and evaluate all items against new criteria\n- **append**: Add new items to existing ones, keeping items that match the new criteria',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Set of key-value pairs you want to associate with this object.',
    )
